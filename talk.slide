Designing go services for CD
Gophercon AU
10:00 1 Nov 2019
Tags: go, cd, tools, gophercon

Am Laher
Lead Engineer (API), Vend 
@amfastic

* My Bold Premise

Continuous Deployment can influence the design of your code, in subtle, but hugely beneficial ways.

Your life, and your code, will be better.

* What is CD?

So many interpretations. Many of them long. 

_From_ [[https://continuousdelivery.com]]_:_

.caption Continuous Delivery is the ability to get changes of all types — including new features, configuration changes, bug fixes and experiments — into production, or into the hands of users, safely and quickly in a sustainable way.

* But ...

How about Continuous Integration, Continuous Delivery, Continuous Fish ...?

: But honestly, there are so many interpretations out there, that I'm going to pick one and talk about that. Apologies in advance if this definition doesn't ring true...

* What is Continuous Deployment?

_For_the_purposes_of_this_talk_..._

	CI := auto(test + build)

_and_

	CD := auto(test + build + deploy)

* What is Continuous Deployment?

_Another_way..._

- A PR triggers tests.  ← *CI*
- A merge [to master] triggers tests, rebuild + redeploy. ← *CD*

* Touted Benefits of CD

- Lowers risk 
- Faster time-to-market
- Higher quality software
- Better products
- Happier teams

: See [[https://continuousdelivery.com]] again
: I mentioned this site because it has great business cases for CD. Go take a look, there's compelling cases for why you should do this...

* First TDD, then BDD, now ... CDDD

: In the same way that testable code benefits, CD can provide many benefits too.
: The biggest change is how you change your code.

* ORLY

.image https://media.giphy.com/media/5b5OU7aUekfdSAER5I/giphy.gif

: * What the?
: - If I make a mistake, will everything break?
: - What about PM approval? Design reviews?
: - Breaking changes? I'm so ded
: Maybe you deploy on a Monday. US is asleep, right?
: Maybe you don't have time for this
: Maybe your legacy software has tricky manual steps, I don't know
: * Don't worry, Morty
: - Manage risk up-front.
: - Smaller Increments make the heart grow calmer.
: - Re-think your change procedure.
: - Unreleased code is risk.

* Real world example

* Toasties Galore

.image ./diagrams/toasties-galore-bw.jpg _ 600

: .image https://cdn.imgbin.com/25/17/2/imgbin-ham-and-cheese-sandwich-toast-cheese-and-tomato-sandwich-grilled-cheese-sandwiches-grilled-cheese-sandwich-illustration-xVCJhHSVh7M9C2Lg3VsZKgZye.jpg _ 500

Meet our heroine, Gita the Gopher

_A_gopher_and_her_dream,_to_make_toasties_for_the_world_..._

* State of the art Techmology 

.image ./diagrams/jafflr-chillybin-bw.jpg _ 800

* Toasties Galore walkthrough

.image diagrams/toasties.svg _ 600

: For this presentation, let's look at the software for an imaginary food truck "Toasties Galore".
: - 2 services - chillybin & jafflr.
: - Chillybin is where we store the ingredients. Chillybins (NZ), also known as an Esky in Australia
: - Jafflr is a state of the art grilling machine.
:   - It harnesses laser technology to melt the cheese ... 
:   - and a mechanical arm to fetch ingredients from the chillybin
: - Both components serve HTTP APIs. chillybin connects to a Postgres database. 
: Testing:
: - Per-service tests work on each service in isolation.
: - Integration tests invoke the APIs and test the interactions.
:   - test environment with docker-compose
: - Supporting scripts
: - Downtimeless deploys

* Getting going with the basics ...

- Integration Tests
- Downtimeless Deploys
- Observability

: .image https://media.npr.org/assets/img/2012/07/03/rubegoldberg_photo_gal_4153_photo_846993380_lr-1-_custom-ecf7c547a1f17966a258fa8bd21286bc9b6d3619-s1100-c15.jpg

* jafflr

.play ./jafflr/main.go /^func main/,/^}/

* Jafflr schematic

.image ./diagrams/jafflr-schematic-diagram.jpg _ 700

* Jafflr arm

.image ./diagrams/jafflr-arm.jpg _ 600

* Chillybin

.image ./diagrams/chillybin.jpg _ 500

* Integration Tests

CD is all about automated testing - _you_need_to_trust_those_tests._

.code -edit ./integration-tests/integration_test.go 

: - Repeatable and reliable - non-racy, non-flaky ... fast
: - Environment - prod-like? Docker/docker-compose? k8s?
: - Write a few integration tests - test those interactions.
: - "Happy Path and some error handling"
: - Don't assume state.

* Graceful Restarts

Stop listening on a port, while continuing to serve existing connections. 
Allow other [new] instances to listen instead.

.code -edit ./tpi/http.go /^func GracefulShutdownOSInterrupt/,/^}/

: switch to code view. Show the tests in action and explain how K8s or ECS would work.

* Observability

- Middleware, metrics

.code -edit ./tpi/http.go /^func TracingMiddleware/,/^}/

* Success

Toasties Galore was highly successful. ...

But ...

* Too many Toasties

Gita noticed that there are a lot of orders, and some of these are getting lost.

* Oh noes, breaking changes

Toastie orders are getting lost, we need to track customers.

- API signature needs to change
- DB structure changes
- HaLp!

* Planned changes

.image diagrams/toasties-changes.svg _ 600

* Obstacles

- Changes ready now but ... let's to wait for a quiet Monday?! ... changes mount
- How to co-ordinate changes - downtime?!
- How to rollback once other changes come in?!
- DB migrations can take time. 

Phew.

* I'm scared, Rick

.image https://media.giphy.com/media/WrK9dwj8TNPr2/giphy.gif

* The Foxtrot

So, let's do a dance.

.image https://media.giphy.com/media/BiA0154sSljkA/giphy.gif

A 3-step dance.

* The 3-step deployment dance

- STEP-1 - Add new endpoint
- STEP-2 - Invoke new endpoint
- STEP-3 - Delete old endpoint

: You could do it without CD, but you should try it with CD. 
: It can be completed in a short time, and lined up just like this. 
: Furthermore, the easier your deploy is, the more you can plan for releases
: Part of the problem with the foxtrot is the 'planning ahead': 
: When releasing is hard, people try to do all this in a single deploy
: When less hard, people tend to aim for Step 2. Step 3 may never happen.
: NOTE: variants include shadowing, canaries, blue-green

* Step 1 - add new feature implementation

- Different URL? Headers? Parameters?
- Behind Feature Flag?
- 2 versions of code in 'master'

* Step 2 - invoke new implementation

- Just switch over?
- Feature Flag?
- Canary/Shadowing/Blue-Green

* Step 3 - delete old implementation

- Do it soon - Tidy Kiwis
- Maybe line it up in advance

It's the easy part, but easy to dismiss. 

* Chilly bin - migrations

.code ./chillybin/main.go /^func runMigrationsSource/,/^}/

* The Foxtrot

When deployment is a non-thing:

- you can make your releases safer
- you code remains cleaner

* On Feature Flags

: TODO

* Other concerns ...

What else can we do differently once deployment becomes a non-thing?

* Configuration 

Extensive config files?

- a popular pattern
- Easy to reconfigure when supporting
- Knobs and twiddles are nice

* But, with CD ...

We can simplify. 

- Just use constants into your code.
- Deployment is fast. Just edit code/artifact
- 12-factor Apps: 'just use ENV variables'.

: Knobs and twiddles - why not bake them in:
: - Where possible, compile it in - simplify your code.
: - In other cases, it can live in the artifact (file in docker image).
: - To reconfigure, change your code - redeploy is as fast as a config change.
: * CD does what?
: 12-Factor Apps 'Environment Variables are enough'
: * Per-environment config
: Things we need to configure boil down to env-specific params 
: - Database DSNs
: - scale-dependent variables
: - Feature flags?

* Tooling

What other tools will we want to build?

* Canaries, Rollbacks

@overlord ...

At Vend we have a slackbot which handles a number of CD-related utilities.

For example: 
 - canary deploys
 - rollbacks
 - feature flagging
 - service status

* On Monorepos

Monorepos offer an additional challenge. 

 - Do we redeploy everything on every change?
 
* Last relevant commit

Calculate changes affecting a service [in a monorepo]

: In a monorepo, it's real useful to know which services are affected by a commit.
: Or put another way, which services have been affected since current production.
: * Current version
: Check 'current version of a service'.

.code ./scripts/last_commit.sh

: - calls `go list -deps` and eventually `| git rev-list`
: - Allows us to run regression tests at the right time.
: - Report that the deploy was really successful.
: This was really just a bash script parsing the json output of `kubectl get pod`. 
: To me this kind of thing is crucial for regression testing.

* Why last_commit.sh ?

- Deploy only affected services.
- Run relevant integration tests, post-deploy

* Conclusions

: I've just tried to show you some go-specific hints about the CI/CD toolchain.
: I didn't even try to recommend a CI system
: It can take some time to redesign your software for Continuous Deployment - after seeing this talk, I hope you’ll begin or complete that journey.

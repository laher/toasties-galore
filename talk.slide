Designing Go services for Continuous Deployment
Gophercon AU
1 Nov 2019
Tags: go, cd, tools, gophercon

Am Laher
Lead Engineer, Vend 
@amfastic

* Begin with a Premise

Continuous Deployment can improve the design of your code in subtle, but remarkable ways.

: Hmm, sounds good, right.
: This is a Go conference, so I'm going to go light on the theory, culture and tools surrounding CD.
: I'll focus on code, on tips and pointers which are relevant to Go.
: But first, ...

* What is this, Continuous Deployment?

_For_the_purposes_of_this_talk_..._

Continuous Deployment is a release strategy: any mainline change [a commit on master] that passes testing, is automatically released into production.

: Contiuous Deployment will automatically put your working software in front of users.
: What's that, do I hear screaming?
: * CD is one of three similar concepts 
: My technical distinction for CI/Cd/CD:
: CI := auto(test + build)                          // Continuous Integration
: Cd := auto(test + build + publish) + easy(deploy) // Continuous Delivery
: CD := auto(test + build + publish + deploy)       // Continuous Deployment
: _Continuous_Delivery_implies_readiness_to_release_working_software_at_any_given_time._
: _Continuous_Deployment_implies_automatic_release._
: So many interpretations and variants ...
: Definition: Continuous Delivery is the ability to get changes of all types — including new features, configuration changes, bug fixes and experiments — into production, or into the hands of users, safely and quickly in a sustainable way.
: I mentioned this site because it has great business cases for CD. Go take a look, there's compelling cases for why you should do this...

* ORLY

OK, OK , I can hear your internal monologue. It does sound super risky.

.image https://media.giphy.com/media/5b5OU7aUekfdSAER5I/giphy.gif

Let's explore...

: I can hear what you're saying to yourself ...
: - If I make a mistake, will everything break?
: - What about PM approval? Design reviews?
: - It sounds like chaos
: There's a lot to get right, I encourage you read up about the tools and culture and ecosystems around CD.
: - there's work to be done, some work culture implications, and some caveats.
: Let's explore ...

* Let's make up a story ...

* Toasties Galore

Meet our heroine, Gita the Gopher.

.image ./diagrams/toasties-galore-bw.jpg _ 600

_Gita_is_an_innovator,_with_a_passion_for_technology_and_melted_cheese._

: This is her food stall, Toasties Galore.
: She's starting a business, and she's going to beat the competition with advanced cheese technology.

* State of the art Techmology 

Gita builds her own machinery, it's software-driven. 

.image ./diagrams/jafflr-chillybin-bw.jpg _ 800

We - *you*and*I* - build the software.

: - Chillybin is where we store the ingredients. A chilly bin (NZ English), also known as an Esky in Australia
: - Jafflr is a state of the art grilling machine.
:   - It harnesses laser technology to melt the cheese just right
:   - and a mechanical arm to fetch ingredients from the chillybin
: Gita is a hardware freak.
: She's also tech savvy and she told us to use CD. She knows her cheese.

* Toasties Galore codebase

An overview

- A monorepo
- 2 HTTP services, which interact
- Tests, tooling, docker things ...
- Scripts
- A CI/CD pipeline

See [[https://github.com/laher/toasties-galore]]

: For this presentation, let's look at the software for an imaginary food stall, "Toasties Galore".
: - 2 services - chillybin & jafflr.
: - Both components serve HTTP APIs. chillybin connects to a Postgres database. 
: Testing:
: - Per-service tests work on each service in isolation.
: - Integration tests invoke the APIs and test the interactions.
:   - test environment with docker-compose
: - Supporting scripts
: - Downtimeless deploys

* Invoking Jafflr

The Toasties Galore software architecture ...

.image diagrams/toasties.dot.svg _ 600

This simple deployment powers a 24-hour, high-throughput toasting service, with some agressive expectations. _Gophers_are_demanding._

* The Pipeline

.image ./diagrams/pipeline.dot.svg

* The pipeline

In this case, we're using [[https://travis-ci.org/laher/toasties-galore/branches][Travis]]

.code ./.travis.yml

: .image https://media.npr.org/assets/img/2012/07/03/rubegoldberg_photo_gal_4153_photo_846993380_lr-1-_custom-ecf7c547a1f17966a258fa8bd21286bc9b6d3619-s1100-c15.jpg

* Eek, auto-deploy is scary

: - Breaking changes? I'm so ded
: Maybe you deploy on a Monday. US is asleep, right?
: Maybe you don't have time for this
: Maybe your legacy software has tricky manual steps, I don't know
: But ...
: * Don't worry, Morty
: - Manage risk up-front.
: - Smaller Increments make the heart grow calmer.
: - Re-think your change procedure.
: - Unreleased code is risk.

* The Baseline

Let's consider some Important Things in our code:

- Observability
- Seamless Deploys
- Integration Tests

* Jafflr schematic

.image ./diagrams/jafflr-schematic-diagram.jpg _ 700

* Jafflr

.play ./jafflr/main.go /^func main/,/^}/

* Observability & Instrumentation

Use metrics to know what's happening in production. e.g.

.code -edit ./tpi/http.go /^func TracingMiddleware/,/^}/

_There's_ [[https://github.com/laher/toasties-galore/blob/059053a/tpi/http.go#L65:L73][another middleware]] _for_logging._

* Harnessing the Rolling Restart

Stop listening, keep handling ... e.g.

.code -edit ./tpi/http.go /^func GracefulShutdown/,/^}/

Continues processing in-flight requests, while making way for a newer deployment.

: Stop listening on a port, while continuing to serve existing connections. 
: Allow other [new] instances to listen instead.
: Rolling Restarts
: switch to code view. Show the tests in action and explain how K8s or ECS would work.

* chillybin client - An interaction

.image ./diagrams/jafflr-arm.jpg _ 600

* Integration Tests

Few tests - verify the interactions

.code -edit ./integration-tests/integration_test.go  /^func TestHappyPath/,/^}/

: Run tests against a 'prod-like' envirnment (could be docker-compose, k8s, ...)
: Invoke outer service, assert inner service
: Doesn't assume state. Check before & after
: Test is independent from environment. With appropriate 'demo customer' things, I could equally run this on prod, local, staging ...
: Needs to be non-racy, non-flaky
: Preferably, fast
: "Happy Path and some error handling"

* Success

Toasties Galore is now a highly successful operation ...

- Gophers love the recipes.
- Jafflr is busy 24-7

But ...

- Some users aren't happy

* Design problems 

We're super busy, and some orders are going to the wrong gophers. 

- Gwenda got pineapple instead of vegemite 
- Gary received cheese instead of Sheese (soy cheese)

Not good.

* What to do?

Decisions ...

*Gita:* Track orders with customer's names

*Us:* alter the Chillybin API to support richer request data

* Planned changes to /pick

.image diagrams/before.dot.svg _ 600

.image diagrams/after.dot.svg _ 600


* Oh noes, Breaking Changes

- API signature needs to change
- DB structure changes
- HaLp!

.image https://media.giphy.com/media/WrK9dwj8TNPr2/giphy.gif

* Us: OMG

*Gita*: s'all good. Let's dance.

* The Foxtrot

So, let's dance.

.image https://media.giphy.com/media/BiA0154sSljkA/giphy.gif

A 3-step dance: 

- Add new implementation 
- Migrate comfortably
- Delete old implementation

* The 3-step release dance

Three steps, or _stages_ ... with CD, it's easy, you'll consider it more often

.image ./diagrams/pulls.png _ 600

: You could do it without CD, but you should try it with CD. 
: It can be completed in a short time, and lined up just like this. 
: Furthermore, the easier your deploy is, the more you can plan for releases
: Part of the problem with the foxtrot is the 'planning ahead': 
: When releasing is hard, people try to do all this in a single deploy
: When less hard, people tend to aim for Step 2. Step 3 may never happen.
: NOTE: variants include shadowing, canaries, blue-green

* Step 1 - Add new feature implementation

- Serve the new approach under a different URL, /v2/pick
- Now there are 2 versions of `pick`, side-by-side.
- v2 can be tested manually, but isn't invoked by any other service yet.
- No changes to calling service (jafflr). Just chillybin.

See [[https://github.com/laher/toasties-galore/pull/1/files]]

* Step 2 - Invoke new implementation

- Use Feature Flags?

	func HasFeature(customer string, feature string) bool {
		switch feature {
		case "pick.v2":
			if customer == "gita" {
				return true
			}
			return false
		default:
			panic("unknown feature")
		}
	}

See [[https://github.com/laher/toasties-galore/pull/2/files]]

- This function could be backed by a service, a db, or by configuration.
- Alternatives: Canary Deploys, Shadowing, Blue-Green deploys

* Step 3 - Delete old implementation

- Do it soon
- Line it up in advance. Plan for it otherwise you'll forget

See [[https://github.com/laher/toasties-galore/pull/3/files]]

It's the easy part, but it's also easy to forget or fear it. 

* The Foxtrot

When deployment is a non-thing:

- you can make your releases safer.
- you code remains cleaner.
- When you have more viable options within reach, you're empowered to make better decisions.

* Tips and Tricks

* On DB Migrations

Migrations are Challenging 

- Altering big tables - time-consuming, performance concerns.
- Rollbacks are awkward.

Where possible:

- Use transactions (Postgres has transactional DDL) to *test* them in advance.
- Make them idempotent (`if not exists`) to *run* them in advance.
- Split them up?

* Chillybin

.image ./diagrams/chillybin.jpg _ 500

* Chilly bin - migrations

.code ./chillybin/main.go /^func runMigrationsSource/,/^}/

: Using go-migrate
: Can run this from the main file
: Alternatively, run it manually in a 'job'
: Deploy the migration scripts as part of the container

* On Configuration 

Extensive config files?

- Configurable-everything is a popular pattern - reconfigure all the things
- Easier to reconfigure while an on-call emergency?
- Knobs and twiddles are nice

* But, with CD ...

We can simplify. 

- Use constants more often
- Use $ENV variables for DSNs and such. [see 12-factor Apps]

Deployment is fast. Just edit code/artifact

: Knobs and twiddles - why not bake them in:
: - Where possible, compile it in - simplify your code.
: - In other cases, it can live in the artifact (file in docker image).
: - To reconfigure, change your code - redeploy is as fast as a config change.
: * CD does what?
: 12-Factor Apps 'Environment Variables are enough'
: * Per-environment config
: Things we need to configure boil down to env-specific params 
: - Database DSNs
: - scale-dependent variables
: - Feature flags?
: * Tooling
: What other tools will we want to build?

* On Monorepos

Monorepos offer some challenges and some advantages

- Benefit: easier to maintain CI/CD pipelines centrally.
- Benefit: in-house dependencies are all local.
- Benefit: testing component combinations is easier.
- Challenge: identifying what to build, test, deploy on each commit.
- Challenge: speed.

Q: Do we really redeploy everything on every change?
A: Depends on language and tooling

* Publish / deploy conditionally - Go

See [[./scripts/publish.sh][publish.sh]] and [[./scripts/deploy.sh][deploy.sh]]

.code -edit ./scripts/publish.sh
 
* Last relevant commit - Go

Calculate changes affecting a service [in a monorepo]

: In a monorepo, it's real useful to know which services are affected by a commit.
: Or put another way, which services have been affected since current production.
: * Current version
: Check 'current version of a service'.

.code ./scripts/last_commit.sh

: - calls `go list -deps` and eventually `| git rev-list`
: - Allows us to run regression tests at the right time.
: - Report that the deploy was really successful.
: This was really just a bash script parsing the json output of `kubectl get pod`. 
: To me this kind of thing is crucial for regression testing.

* Why last_commit.sh ?

- Deploy only affected services.
- Decide which integration tests to run, post-deploy

* DIY Tooling

At Vend we have a slackbot, @overlord, which offers a number of CD-related utilities. e.g.

- canary deploys
- rollbacks
- feature flagging
- service status

: these are the kinds of tools which you may end up writing code for.

* On CI/CD Software

They all work, and they're all different. I've tried heaps. 

_My_examples_are_only_chosen_to_communicate_some_ideas._

Just choose one.

* Conclusions

* How will it change my code?

_More_than_anything_else,_CD_affects_ *how* _you_ *change* _your_code._

- CD forces you to deal with Important Things, up front.
- CD encourages good practices.
- CD enables safe and easy changes.

Impact:

- Simpler: fewer contraptions in the code.
- Tidyier: fewer cobwebby corners.
- More dynamic: change is simpler -> more options.

* Advice

It can be hard to retrofit CD. Start early.

See [[https://continuousdelivery.com]] for research and business speak.

: Touted Benefits
: Continuous Deployment will empower you to make better choices, and encourage you to develop good practices early on.
: CD means [[https://continuousdelivery.com][reduced risk, faster time-to-market, higher quality, better products, *happier*teams*]]...

* Advice: Play with Toasties Galore

See Toasties Galore on [[https://github.com/laher/toasties-galore][github]] or [[https://travis-ci.org/laher/toasties-galore][travis]] to try this stuff out - maybe it'll help you.

: Thanks
: I hope that helped encourage you along this journey.
: If you don't have it early on, you may have a lot more work to do, but each of these efforts has a payoff.
: I've just tried to show you some go-specific hints about the CI/CD toolchain.
: I skipped whole areas - CI systems, rollbacks, cultural obstacles, ...
: I didn't even try to recommend a CI system
: It can take some time to redesign your software for Continuous Deployment - after seeing this talk, I hope you’ll begin or complete that journey.

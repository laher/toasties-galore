Designing go services for CD
Gophercon AU
10:00 1 Nov 2019
Tags: go, cd, tools, gophercon

Am Laher
Lead Engineer (API), Vend 
@amfastic

* Begin with a Premise

Continuous Deployment can benefit the design of your code, in subtle, but remarkable ways.

* Overview

- 00:00 Bold Premise
- 01:00 Defining terms
- 07:00 *Set*a*scene*: Introduce Characters & Foundational Work
- 17:00 *Conflict*and*Resolution*: Problematic Scenario -> Action 
- 30:00 Various tidbits 
- 38:00 Conclusion
- 40:00 Questions

* What is Continuous Deployment?

Different things to different people.

_For_the_purposes_of_this_talk_..._

* What is Continuous Deployment?

Continuous deployment is a release strategy: any main-branch commit that passes testing is automatically released into production.


Pushing/merging to master will automatically put your working software, directly into production.

* Some related concepts

	ContinuousIntegration := auto(test + build)
	ContinuousDelivery    := auto(test + build + publish) + easy(deploy)
	ContinuousDeployment  := auto(test + build + publish + deploy)


_Continuous_Delivery_implies_readiness_to_release_working_software_at_any_given_time._
_Continuous_Deployment_implies_immediate_release._
_We're_talking_about_the_latter._

: Creating a Pull Request triggers a test, and usually generates a build artifact.
: * What does the internet say?
: So many interpretations and variants ...
: _From_ [[https://continuousdelivery.com]]_:_
: .caption Continuous Delivery is the ability to get changes of all types — including new features, configuration changes, bug fixes and experiments — into production, or into the hands of users, safely and quickly in a sustainable way.
: Benefits: Lowers risk, faster time-to-market, higher quality, better products, *happier*teams* 
: (Continuous Delivery is a similar concept)
: * But ...
: How about Continuous Integration, Continuous Delivery, Continuous Fish ...?
: But honestly, there are so many interpretations out there, that I'm going to pick one and talk about that. Apologies in advance if this definition doesn't ring true...
: * On Tools
: So many tools for CI/CD, so many deployment scenarios
: They all work, and they're all different. 
: _My_examples_are_only_chosen_to_communicate_some_ideas._
: * Touted Benefits of CD
: - Lowers risk 
: - Faster time-to-market
: - Higher quality software
: - Better products
: - Happier teams
: See [[https://continuousdelivery.com]] again
: I mentioned this site because it has great business cases for CD. Go take a look, there's compelling cases for why you should do this...
: * First TDD, then BDD, now ... CDDD
: In the same way that testable code benefits, CD can provide many benefits too.
: The biggest change is how you change your code.

* How will it change my code?

_More_than_anything_else,_CD_changes_how_you_ *change* _your_code._

- CD forces you to deal with Important Things, up front.
- CD enables safe and easy changes.

Impact:

- Simpler: fewer contraptions in the code.
- Tidyier: fewer cobwebby corners.
- More dynamic: change is simpler -> more options.

* ORLY

.image https://media.giphy.com/media/5b5OU7aUekfdSAER5I/giphy.gif

OK, OK, there's a cost and some caveats... Let's explore

: * What the?
: - If I make a mistake, will everything break?
: - What about PM approval? Design reviews?
: - Breaking changes? I'm so ded
: Maybe you deploy on a Monday. US is asleep, right?
: Maybe you don't have time for this
: Maybe your legacy software has tricky manual steps, I don't know
: * Don't worry, Morty
: - Manage risk up-front.
: - Smaller Increments make the heart grow calmer.
: - Re-think your change procedure.
: - Unreleased code is risk.

* Let's set the scene  ...

* Toasties Galore

Meet our heroine, Gita the Gopher.

.image ./diagrams/toasties-galore-bw.jpg _ 600

_Gita_is_an_innovator,_with_a_passion_for_technology_and_melted_cheese._

: .image https://cdn.imgbin.com/25/17/2/imgbin-ham-and-cheese-sandwich-toast-cheese-and-tomato-sandwich-grilled-cheese-sandwiches-grilled-cheese-sandwich-illustration-xVCJhHSVh7M9C2Lg3VsZKgZye.jpg _ 500

* Toasties Galore codebase

An overview

- A monorepo
- 2 HTTP services, which interact
- Tests, tools, docker things ...
- A CI/CD pipeline

See [[https://github.com/laher/toasties-galore]]

: For this presentation, let's look at the software for an imaginary food stall, "Toasties Galore".
: - 2 services - chillybin & jafflr.
: - Chillybin is where we store the ingredients. Chillybins (NZ), also known as an Esky in Australia
: - Jafflr is a state of the art grilling machine.
:   - It harnesses laser technology to melt the cheese to precisely 6.3 kilogoos ... 
:   - and a mechanical arm to fetch ingredients from the chillybin
: - Both components serve HTTP APIs. chillybin connects to a Postgres database. 
: Testing:
: - Per-service tests work on each service in isolation.
: - Integration tests invoke the APIs and test the interactions.
:   - test environment with docker-compose
: - Supporting scripts
: - Downtimeless deploys

* State of the art Techmology 

.image ./diagrams/jafflr-chillybin-bw.jpg _ 800

* Invoking Jafflr

The Toasties Galore software architecture ...

.image diagrams/toasties.dot.svg _ 600

This simple deployment powers a 24-hour, high-throughput toasting service, with some agressive expectations. _Gophers_are_demanding._

* The Pipeline

.image ./diagrams/pipeline.dot.svg


* The pipeline

In this case, we're using [[https://travis-ci.org/laher/toasties-galore/branches][Travis]]

.code ./.travis.yml

: .image https://media.npr.org/assets/img/2012/07/03/rubegoldberg_photo_gal_4153_photo_846993380_lr-1-_custom-ecf7c547a1f17966a258fa8bd21286bc9b6d3619-s1100-c15.jpg

* Eek, auto-deploy is scary

* The Baseline

Let's consider some Important Things in our code:

- Observability
- Seamless Deploys
- Integration Tests

* Jafflr schematic

.image ./diagrams/jafflr-schematic-diagram.jpg _ 700

* Jafflr

.play ./jafflr/main.go /^func main/,/^}/

* Observability & Instrumentation

Use metrics to know what's happening in production. e.g.

.code -edit ./tpi/http.go /^func TracingMiddleware/,/^}/

_There's_ [[https://github.com/laher/toasties-galore/blob/059053a/tpi/http.go#L65:L73][another middleware]] _for_logging._

* Harnessing the Rolling Restart

Stop listening, keep handling ... e.g.

.code -edit ./tpi/http.go /^func GracefulShutdown/,/^}/

Continues processing in-flight requests, while making way for a newer deployment.

: Stop listening on a port, while continuing to serve existing connections. 
: Allow other [new] instances to listen instead.
: Rolling Restarts
: switch to code view. Show the tests in action and explain how K8s or ECS would work.

* chillybinClient 

.image ./diagrams/jafflr-arm.jpg _ 600

* Integration Tests

Few tests - verify the interactions

.code -edit ./integration-tests/integration_test.go  /^func TestHappyPath/,/^}/

: CD is all about automated testing - _you_need_to_trust_those_tests._
: - Repeatable and reliable - non-racy, non-flaky ... fast
: - Environment - prod-like? Docker/docker-compose? k8s?
: - Write a few integration tests - test those interactions.
: - "Happy Path and some error handling"
: - Don't assume state.

* Success

Toasties Galore is now a highly successful operation ...

- Gophers love the recipes.
- Jafflr is busy 24-7

But ...

- Some users aren't happy

* Design problems 

We're super busy, and some orders are going to the wrong gophers. 

- Gary received cheese instead of Sheese (soy cheese)
- Gwenda got pineapple instead of vegemite 

Not good.

* What to do?

Decisions ...

*Gita:* Track orders with customer's names

*Gita:* change the Chillybin API to support richer request data

* Planned changes

.image diagrams/before.dot.svg _ 600

.image diagrams/after.dot.svg _ 600


* Oh noes, Breaking Changes

- API signature needs to change
- DB structure changes
- HaLp!

.image https://media.giphy.com/media/WrK9dwj8TNPr2/giphy.gif

* Obstacles

*Us*: Changes ready now but ... let's to wait for a quiet Monday?! 
*Us*: Monday - other changes incoming, things be complicated
*Us*: How to co-ordinate breaking changes - downtime?!
*Us*: DB migrations - can take a long time, can interfere with deploys. 
*Us*: How to rollback once other changes come in?!

*Gita*: s'all good. Let's dance.

* The Foxtrot

So, let's dance.

.image https://media.giphy.com/media/BiA0154sSljkA/giphy.gif

A 3-step dance: 

- Add new implementation 
- Migrate comfortably
- Delete old implementation

* The 3-step release dance

Three steps, or _stages_ ... with CD, it's easy, you'll consider it more often

.image ./diagrams/pulls.png _ 600

See [[https://github.com/laher/toasties-galore/pulls][Pull Requests]]

: You could do it without CD, but you should try it with CD. 
: It can be completed in a short time, and lined up just like this. 
: Furthermore, the easier your deploy is, the more you can plan for releases
: Part of the problem with the foxtrot is the 'planning ahead': 
: When releasing is hard, people try to do all this in a single deploy
: When less hard, people tend to aim for Step 2. Step 3 may never happen.
: NOTE: variants include shadowing, canaries, blue-green

* Step 1 - Add new feature implementation

- Serve the new approach under a different URL, /v2/pick
- v2 doesn't affect real users [yet], but you can test it
- Now there are 2 versions of `pick`, side-by-side

See [[https://github.com/laher/toasties-galore/pull/1/files]]

* Step 2 - Invoke new implementation

- Use Feature Flags?

	func HasFeature(customer string, feature string) bool {
		switch feature {
		case "pick.v2":
			if customer == "gita" {
				return true
			}
			return false
		default:
			panic("unknown feature")
		}
	}

See [[https://github.com/laher/toasties-galore/pull/2/files]]

- This function could be backed by a service, a db, or by configuration.
- Alternatives: Canary Deploys, Shadowing, Blue-Green deploys

* Step 3 - Delete old implementation

- Do it soon
- Line it up in advance. Plan for it otherwise you'll forget

See [[https://github.com/laher/toasties-galore/pull/3/files]]

It's the easy part, but it's also easy to forget or fear it. 

* The Foxtrot

When deployment is a non-thing:

- you can make your releases safer
- you code remains cleaner

* On DB Migrations

Migrations are Challenging 

- big tables - time-consuming
- rollbacks are complex

Where possible:

- make them idempotent (`if not exists`)
- use transactions
- run them in advance

* Chillybin

.image ./diagrams/chillybin.jpg _ 500

* Chilly bin - migrations

.code ./chillybin/main.go /^func runMigrationsSource/,/^}/

* On Configuration 

Extensive config files?

- a popular pattern
- Easy to reconfigure when supporting
- Knobs and twiddles are nice

* But, with CD ...

We can simplify. 

- Just use constants into your code.
- Deployment is fast. Just edit code/artifact
- 12-factor Apps: 'just use ENV variables'.

: Knobs and twiddles - why not bake them in:
: - Where possible, compile it in - simplify your code.
: - In other cases, it can live in the artifact (file in docker image).
: - To reconfigure, change your code - redeploy is as fast as a config change.
: * CD does what?
: 12-Factor Apps 'Environment Variables are enough'
: * Per-environment config
: Things we need to configure boil down to env-specific params 
: - Database DSNs
: - scale-dependent variables
: - Feature flags?
: * Tooling
: What other tools will we want to build?

* On Monorepos

Monorepos offer some challenges and some advantages

- Benefit: easier to maintain CI/CD pipelines centrally.
- Benefit: 1st party dependencies are all local.
- Benefit: testing component combinations is easier.
- Challenge: speed.
- Challenge: identify what to build, test, deploy on each commit.

Q: Do we really redeploy everything on every change?
A: Ideally, no.

* deploy.sh

.code -edit ./scripts/deploy.sh
 
* Last relevant commit

Calculate changes affecting a service [in a monorepo]

: In a monorepo, it's real useful to know which services are affected by a commit.
: Or put another way, which services have been affected since current production.
: * Current version
: Check 'current version of a service'.

.code ./scripts/last_commit.sh

: - calls `go list -deps` and eventually `| git rev-list`
: - Allows us to run regression tests at the right time.
: - Report that the deploy was really successful.
: This was really just a bash script parsing the json output of `kubectl get pod`. 
: To me this kind of thing is crucial for regression testing.

* Why last_commit.sh ?

- Deploy only affected services.
- Run relevant integration tests, post-deploy

* Canaries, Rollbacks, Tooling

At Vend we have a slackbot, @overlord, which offers a number of CD-related utilities. e.g.

- canary deploys
- rollbacks
- feature flagging
- service status

* Conclusions

* Advice

Start with CD, you won't look back.

If you don't have it early on, you may have a lot more work to do, but each of these efforts has a payoff.

: I've just tried to show you some go-specific hints about the CI/CD toolchain.
: I skipped whole areas - CI systems, rollbacks, cultural obstacles, ...
: I didn't even try to recommend a CI system
: It can take some time to redesign your software for Continuous Deployment - after seeing this talk, I hope you’ll begin or complete that journey.
